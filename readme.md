# INTERN INFOTECS

# Тестовое задание по направлению "Разработчик C++" by Tamelaos (aka AlgoApi)

## Структура проекта
> [!TIP]
> В папке src в header файлах (.h) есть максимально подробные коментарии. Для функции main коментарии находяться в .cpp файле. 
> При наведении курсора на функцию, она также всплывёт

Репозиторий состоит из трёх директорий:
- Директория src - исходный код
    - файл - logger.cpp - исходный код динамической библеотеки из первой части
    - файл - logger.h - header файл, подключающий не сторонние библеотеки и описывающий прототипы функций с комантариями формата Doxygen
    - файл - mainframe.cpp - исходный код второй части - приложения для теста динамической библеотеки
    - файл - mainframe.h - header файл, подключающий не сторонние библеотеки и описывающий прототипы функций с комантариями формата Doxygen
    - файл - Makefile - о нём позже
- Директория materials - дополнительные материалы и заготовки для тестирования
    - файл .clang-format содержит правила форматирования кода и на который я опирался
    - файл test_input.txt пример ввода для теста
    - файл test_expected.txt эталонный файл верного выхода при test_input.txt без учёта времени
    - файл test_output.txt пустой файл для заполенения программой
- Директория build - результаты компиляции и линковки
    - поддиректория bin - готовая скомпилированная программа из второй части, которая ищет динамическу библеотеку на одну директорию ниже и в папке libs
    - поддиректория lib - динамические библеотеки .so
    - поддиректория obj - вспомогательная директория, хранит объектные файлы

> [!IMPORTANT]
> Перед запуском в режиме теста убедитесь что файл test_output.txt пуст

## Компиляция и сборка
> [!NOTE]
> Тестовые параметры: '''../materials/test_output.txt info < ../materials/test_input.txt'''

MakeFile предусматривает:
- all - полная сборка
- all_test - полная сборки с дополнительным сравнением эталона с выходом программы
- all_lint - проверка cppcheck, clang-format, полная сборка, запуск через valgrind, компиляция и запуск со всеми значениями -fsanitize и с тестовыми параметрами
- clean - очистка build/obj
- clean_all - очистка build
- rebuild - очиста и полная сборка
- check - проверка cppcheck, clang-format
- logger_so - сборка только динамической библеотеки логгера
- mainframe_o - сборка только объектного файла тестового приложения для логгера (вторая часть)
- sanitize - сборка и запуск с тестовыми параметрами со всеми значениями -fsanitize
- valgrind - сборка и запуск с тестовыми параметрами через valgrind

> [!TIP]
> отчёт valgrind формируется в src директории в файле valgrind.log, -fsanitize сразу пишет в консоль если есть ошибки
> подробнее о проверках, которые программа проходит успешно моежете узнать в папке materials и файле instructions_for_testing_rus.md

## Использование

> [!IMPORTANT]
> Директория запуска будет являться директорией, относительно которой необходимо указывать пути до файлов. 
> Пути с пробелами необходимо обернуть в двойные кавычки. 
> Файлы для записи могут иметь расширение только .txt или .log.

Доступные типы/уровни логирования/важности: debug, info, warn, error, critical

В папке build/bin будут находиться файлы начинающиеся на main, через '_' указывается модификация, но все принимают 2 консольных параметра первый путь до файла записи, а второй уровень важности записи по умолчанию, кроме main_test, ему дополнительно третьим параметром необходим путь эталонного вывода программы для сравнения результата работы программы.
- main - без модификации (make all)
- main_address - с инструментом для обнаружения ошибок доступа к памяти во время выполнения (make sanitize)
- main_leak - с инструментом для обнаружения утечек памяти во время выполнения (make sanitize)
- main_undefined - c инструментом для обнаружения неопределённого поведения во время выполнения (make sanitize)
- main_unreachable - c инструментом для обнаружения недостижимых точек программы (make sanitize)
- main_test - как обычный, но с дополнительным сравнением эталона с выходом программы (make all_test)

В консоль вводяться строки формата: "<уровень/важность лога>:<сообщение>" для записи в журнал (например: "error:no response").

Чтобы изменить уровень/важность лога по умолчанию в консоль ввводится строка формата: "$set_default:<новое значение уровеня/важности лога>" (например: "$set_default:debug").

Если в параметрах консоли введённый уровень/важность не распознана, то по умолчанию устанавливается - info.

Если введённая запись имеет уровень/важность ниже уровеня/важности по умолчанию, то эта запись не попадёт в журнал.

Если введный уровень/важность записи не распознана или не введена, будет использоваться уровень/важность по умолчанию (например: "response!")

Чтобы завершить работу программи необходимо ввести в консоль: "exit" или нажать сочетание клавишь Cntl+C и нажать Enter.

> [!CAUTION]
> main_address, main_leak, main_undefined, main_unreachable - не будут работать с valgrind, используйте main и/или main_test

# Соответствие требованиям (по пунктам)

## Часть 1 — библиотека
Динамическая библиотека. Библиотека собрана как разделяемая библиотека (.so) и может подключаться динамически при сборке/запуске тестового приложения.

### Параметры инициализации

При инициализации библиотека принимает имя файла журнала и уровень важности по умолчанию.
Уровни важности реализованы через enum с понятными именами: debug, info, warn, error, critical.

### Содержимое записи в журнале
Для каждой записи сохраняется: текст сообщения, уровень важности, метка времени (формат ISO-8601/HH:MM:SS).

### Изменение уровня по умолчанию
После инициализации предусмотрен публичный метод для изменения уровня важности по умолчанию.

### Логика фильтрации
Cообщения с уровнем ниже текущего порога не записываются.

## Часть 2 — тестовое приложение

### Использование библиотеки
Приложение подключает динамическую библиотеку и использует её API для записи сообщений.

### Ввод сообщений и уровня
В консоли приложение принимает строку сообщения и (опционально) уровень важности; если уровень не указан, используется уровень по умолчанию приложения.

### Отправка в отдельный поток
Для записи используется отдельный рабочий поток: основной поток принимает ввод пользователя и помещает данные в потокобезопасную очередь; 

рабочий поток извлекает элементы и вызывает API библиотеки для записи.

Передача данных потокобезопасная: реализована через защищённую очередью (std::mutex + std::condition_variable + std::queue).

### Ожидание нового ввода
После передачи данных основной поток немедленно возвращается к ожиданию ввода, приложение остаётся отзывчивым.

### Параметры приложения
Приложение принимает аргументы командной строки: имя файла журнала и уровень важности по умолчанию, дополнительно может принимать путь до эталонного файла для сравнения

### Внутренняя логика
Архитектура приложения — ООП: есть класс логгера, менеджера очереди/воркера и обёртка для библиотеки логирования; очередь сообщений, корректная остановка потоков при завершении, обработка ошибок.

## Технологии и требования окружения, сборки

Язык: C++17.
Компилятор: gcc (Makefile настроен для работы в Linux).
Внешние библиотеки: не используются (только STL).
Целевая ОС: актуальные версии Ubuntu/Debian/Arch (протестировано на Arch Linux).

Makefile:
Разделены цели для сборки библиотеки и приложения: logger_so, mainframe_o или test_mainframe_o.
Также предусмотрены make all_test, all_lint и clean для удаления временных/промежуточных объектных файлов.
Флаги компиляции: -pthread; -lstdc++; -L; -fsanitize; -std=c++17; -fPIC и -shared для библиотеки; дефолтный набор предупреждений об ошибках.

Репозиторий:
Все исходники, Makefile и доп файлы находятся в едином git-репозитории.
В папке исходного кода отсутствуют временные и промежуточные файлы;
README содержит инструкции по сборке и запуску.

## Надёжность и обработка ошибок
Корректная обработка ошибок при открытии/записи в файл или внезапного исчезновения файла/доступа к файлу: ошибки возвращаются вызывающему коду и корректно отображаются в консоли.
Корректный доступ к общим ресурсам, безопасное завершение приложения (join для потоков, flush/close файла).